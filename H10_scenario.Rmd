---
title: "Rpath using R Ecosystem"
author: "Ralien Purco"
date: "`r Sys.Date()`"
---

# Test for productivity hypothesis (H10 EWE software)


```{r, echo = F}
# Install package


# remove.packages("Rpath")
remotes::install_github('Purco/Rpath_fork')
```

```{r rpath load, echo = F}
# Run package
library(Rpath); library(data.table)
```


```{r}
# Run package for combination
library(gtools) 
# Generate all possible combinations of 4 values that sum to 100
combinations <- permutations(n = 100, r = 4, v = 1:100)

# Filter valid combinations (sum to 100)
valid_combinations <- subset(combinations, rowSums(combinations) == 100)

valid_combinations <-as.data.frame(valid_combinations)

valid_combinations$scenario<-paste("scenario",rownames(valid_combinations),sep="")

library(tidyverse)

valid_combinations=valid_combinations %>%pivot_longer(cols=c(1:4),names_to = "sp_scn", values_to = "prc_scn")

data.valid_combinations=as.data.frame(valid_combinations)

list_combinations=list()
scenarios<-unique(data.valid_combinations$scenario)

for (i in 1:length(scenarios)) {
 list_combinations[[i]]=subset(data.valid_combinations,scenario==scenarios[i])
}


list_comb=list_combinations
```


# Add data


```{r,echo=FALSE,warning = FALSE,message = FALSE}
# define list of packages in vector
package<-c("readxl")

# define function to load all packages
instal<-function(x){ 
  for(pkg in x){
  instal=require(pkg, character.only = T) # load package x 
}}
instal(package) # load list of packages in vector package

```

```{r,include=FALSE,warning = FALSE,message = FALSE}
# set working directory
# setwd("C:/Users/prralien/Nextcloud/RENK/A_Purco/ThÃ¨se_Purco/Ecopath_R/Rpath_fork")

# Import data
# data_ini<-read_excel("Stocking_Hypothesis.xlsx",sheet = 1)
```


```{r,include=FALSE,warning = FALSE,message = FALSE}
data_ini.ad<-read_excel("Stocking_Hypothesis_ad.xlsx",sheet = 1)
data_ini.juv<-read_excel("Stocking_Hypothesis_juv.xlsx",sheet = 1)
```


```{r}
list_comb.d=list()
for (i in 1:length(scenarios)) {
 list_comb.d[[i]]=cbind(data_ini.ad,list_comb[[i]])
}

for (i in 1:length(scenarios)) {
 list_comb.d[[i]]=rbind(list_comb.d[[i]],data_ini.juv)
}
```

# Calcul
```{r}
for (i in 1:length(scenarios)) {
 list_comb.d[[i]]=rbind(list_comb.d[[i]],data_ini.juv)
}
```



```{r}
for (i in 1:nrow(valid_combinations)) {
 list_combinations[[i]]=subset(valid_combinations,scenario==scenarios[i])
}
```


```{r}
for (i in 1:length(scenarios)) {
     
list_comb[[1]]=t(list_comb[[1]][c(1:4)])
      
 dd[[i]]$rS_d=0
       
       dd[[i]]$rvol.sum.c=0
       dd[[i]]$rH_d=0
       
       dd[[i]]$rdvol.sum=0
       dd[[i]]$rA_d=0
}

```




```{r}
for (i in 1:length(dd)) {
       dd[[i]]$rvol.sum=0
       dd[[i]]$rS_d=0
       
       dd[[i]]$rvol.sum.c=0
       dd[[i]]$rH_d=0
       
       dd[[i]]$rdvol.sum=0
       dd[[i]]$rA_d=0
}

```



```{r,include=F,warning=F, error=FALSE, message=F}
data_1=data %>% group_by(year,espece,model,sc.clim, CO2, prop.y,GRECO.sim,sc.g,d.strss,Tm,vol.sum.c)%>%tally()%>%dplyr::select(-n)

a=data_1
a$pj=paste(a$GRECO.sim,a$sc.g,a$espece,a$prop.y,a$sc.clim,a$CO2,a$model,sep = "_")

b=unique(a$pj)

c=list()

for (i in 1:length(b)) {
  c[[i]]=subset(a,pj==b[i])
}


an=c("2020","2030","2040","2050","2060","2070","2080","2090","2095")
an1=as.numeric(an)
g=c

for (i in 1:length(g)) {
  g[[i]]=g[[i]][g[[i]]$year%in%an1,]
}

cc=c

for (i in 1:length(cc)) {
  cc[[i]]$year=as.numeric(cc[[i]]$year)
}


hh=g
for (i in 1:length(hh)) {
       hh[[i]]$d.strssm=0
       hh[[i]]$Tmh=0
}


for (i in 1:length(hh)) {
    for (k in 1:length(an1)){
    hh[[i]]$d.strssm[k]=mean(cc[[i]]$d.strss[1:(an1[k]-2009)])
}
}

for (i in 1:length(hh)) {
    for (k in 1:length(an1)){
    hh[[i]]$Tmh[k]=mean(cc[[i]]$Tm[1:(an1[k]-2009)])
}
}
```


```{r,include=F,warning=F, error=FALSE, message=F}
ccc=c
for (i in 1:length(ccc)) {
  for (k in 1:(length(ccc[[1]]$year)-3)) {

  ccc[[i]]$volsumc[k]=sum(ccc[[i]]$vol.sum.c[1:k])
  
    
}}

cccc=do.call(rbind.data.frame,ccc)
cccc=cccc[,-c(9:12)]
cccc=cccc%>%dplyr::rename(vol.sum.c=volsumc,year.1=year)
```


```{r,include=F,warning=F, error=FALSE, message=F}
e=do.call(rbind.data.frame,hh)
e=e[,-c(9:11)]
data_e=e%>%dplyr::rename(year.1=year,Tm=Tmh,d.strss=d.strssm)

data_ee=merge(data_e,cccc)
```





```{r groups}
#Groups and types for the H10

groups <- c('Common_carp', 
            'Pike_perch', 
            'Roach',
            'Tench', 
            'Roach_juv', 
            'Tench_juv', 
            'Macroinvertebrate', 
            'Zooplancton', 
            'Phytoplancton',
            'Detritus')

types  <- c(rep(0, 8), 1, 2)
stgroups <- c(rep(0, 10))

REco.params <- create.rpath.params(group = groups, type = types,stgroup=stgroups)
```




REco.params now contains a list of 4 objects: model, diet, stanzas, and pedigree.
The majority of the parameters are populated with NA save those that have logical
default vaules (i.e 0.66667 for VBGF_d).  

### Model parameters
 

```{r blank modfile table, echo=FALSE, results='asis'}
knitr::kable(REco.params$model, caption = 'Example of the model list created using the 
             `create.rpath.param` function')
```


Note the use of the operator ':=' to assign values.  This is unique to data tables.
Eg: REco.params$model[Group %in% c('Seals', 'Megabenthos'), EE := 0.8]

```{r Model Table partial, echo = F}
knitr::kable(REco.params$model[, list(Group, Type, Biomass, EE)], 
             caption = 'Example of assigning a specific slot or a whole column')

```

Here are the rest of the columns for the model list.
```{r Model Table sans stanzas}
#Model
## Biomass
biomass <- c(1.44,
             0.56,
             1.34,
             0.93,
             0.45,
             0.16,
             0.25,
             0.54,
             1.92,
             48.81)

## Production by biomass

pb <- c(1.69,
        1.52,
        0.71,
        0.48,
        2.00,
        2.00,
        14.50,
        92.43,
        118.7,
        NA)

## Consumption by biomass

qb <- c(4.93,
        2.19,
        5.09,
        5.18,
        5.29,
        5.14,
        48.33,
        308.1,
        rep(NA,2))
```


```{r Model Table sans stanzas}
REco.params$model[, Biomass := biomass]
REco.params$model[, PB := pb]
REco.params$model[, QB := qb]
```



```{r}
# #Fisheries
# #Landings
# fleet <- c(rep(NA, 11))
# REco.params$model[, Fleet := fleet]
# 
# #Discards
# 
# fleet.d <- c(rep(NA, 11))
# REco.params$model[, Fleet.disc := fleet.d]
```

```{r Model Table sans stanzas}
#Biomass accumulation 
REco.params$model[, BioAcc  := c(2.28,0.83,0.93,0.43,rep(0, 6))]

# Unassimilated consumption
REco.params$model[, Unassim := c(rep(0.2, 6), rep(0.4, 2), rep(0, 2))]

#Detrital Fate
REco.params$model[, Detritus := c(rep(1, 9), rep(1, 1))]
# REco.params$model[, Discards := c(rep(0,10))]
# 
# #Fisheries
# #Landings
# trawl  <- c(rep(0, 4), 0.08, 0, 0.32, 0, 0.09, 0, 0.05, 0.2, rep(0, 10), rep(NA, 3))
# mid    <- c(rep(0, 12), 0.3, 0.08, 0.02, rep(0, 7), rep(NA, 3))
# dredge <- c(rep(0, 15), 0.1, 0.5, rep(0, 5), rep(NA, 3))
# REco.params$model[, Trawlers := trawl]
# REco.params$model[, Midwater := mid]
# REco.params$model[, Dredgers := dredge]
# 
# #Discards
# trawl.d  <- c(1e-5, 1e-7, 0.001, 0.001, 0.005, 0.001, 0.009, 0.001, 0.04, 0.001,
#               0.01, 0.08, 0.001, 0.001, 0.001, rep(0, 7), rep(NA, 3))
# mid.d    <- c(rep(0, 2), 0.001, 0.001, 0.01, 0.001, 0.01, rep(0, 4), 0.05, 0.05,
#               0.01, 0.01, rep(0, 7), rep(NA, 3))
# dredge.d <- c(rep(0, 3), 0.001, 0.05, 0.001, 0.05, 0.001, 0.05, 0.001, 0.01, 0.05,
#               rep(0, 3), 0.09, 0.01, 1e-4, rep(0, 4), rep(NA, 3))
# REco.params$model[, Trawlers.disc := trawl.d]
# REco.params$model[, Midwater.disc := mid.d]
# REco.params$model[, Dredgers.disc := dredge.d]
```

```{r Model Table final, echo = F}
knitr::kable(REco.params$model, 
             caption = 'Example of completed model list')

```

###Stanza Parameters




###Diet Parameters

Note : 
eg: REco.params$diet[Group == 'OtherGroundfish', Seabirds := 0.1]
knitr::kable(REco.params$diet[, list(Group, Seabirds, Whales)])
NA: import

Here is the completed model parameter file for R Ecosystem:

```{r diet fill}

REco.params$diet[, Common_carp       := c(NA,NA,NA,NA, 0.01, 0.01, 0.18, 0.22,0.12,0.46,NA)]
                 
REco.params$diet[, Pike_perch        := c(NA,NA,NA,NA, 0.28, 0.02, 0.12, 0.56,NA,0.02,NA)]
 
REco.params$diet[, Roach             := c(NA,NA,NA,NA,NA,NA, 0.02, 0.25,0.14,0.59,NA)]

REco.params$diet[, Tench             := c(NA,NA,NA,NA,NA,NA, 0.22, 0.12,0.10,0.56,NA)]

REco.params$diet[, Roach_juv         := c(NA,NA,NA,NA,NA,NA, 0.01, 0.20,0.39,0.40,NA)]

REco.params$diet[, Tench_juv         := c(NA,NA,NA,NA,NA,NA, 0.01, 0.15,0.24,0.60,NA)]

REco.params$diet[, Macroinvertebrate := c(NA,NA,NA,NA,NA,NA, 0.08, 0.16,0.35,0.41,NA)]

REco.params$diet[, Zooplancton     := c(NA,NA,NA,NA,NA,NA, NA, 0.11,0.27,0.62,NA)]


```
```{r Dietfile Table, echo = F}
knitr::kable(REco.params$diet, caption = 'Diet parameters for R Ecosystem')
```

```{r}
colSums(REco.params$diet[,2:length(REco.params$diet)],na.rm = T)


```



###Pedigree parameters
Rpath does not currently use pedigrees however, future Rpath extensions will use
them.  Therefore we include them in the current parameter object. The
default values are 1 (low confidence).  These defaults are not changed for R
Ecosystem but can obviously be changed in a similar manner to the other parameter
files.
```{r pedigree table, echo = F}
knitr::kable(REco.params$pedigree, caption = 'Pedigree parameters for R Ecosystem')
```

## Running Ecopath


After creating the parameter object, running ecopath in R is relatively 
straightforward.  It is just the function `rpath` supplied with the parameter object.
Additionally, you can supply an ecosystem name for the output.

```{r Running ecopath}
REco <- rpath(REco.params, eco.name = 'R Ecosystem')
REco
```

The output object from `rpath` is an S3 object type called 'Rpath'.  Rpath objects
are a list of parameters from the mass balance.  However, the `print` function will
display the same information as the "Basic Estimates" tab from EwE. You will also 
notice that the `print` function will display whether the model is balanced or not.
If the model was not balanced, it would list the groups that are not balanced.

You can also display the mortalities associated with each group by supplying the
argument `morts = T` to the `print` function.

```{r Ecopath morts}
print(REco, morts = T)
```

Note that if you wish to save the `print` output you need to use the function
`write.rpath`.  This function will also accept the argument 'morts = T'.

The generic function `summary` will display some summary statistics on the model
as well as a list of attributes you can access.  To access any of the other 
attributes simply use the standard list notation.

```{r Ecopath summaries}
summary(REco)
REco$TL
```

One of the advantages of R is its graphical ability.  Users can feel free to develop
their own graphical routines for the Rpath outputs.  However, we have included
a basic food web plot.  The routine can include fisheries, display group numbers or 
names, and even highlight a particular group.

```{r Food Web Plots, fig.align = 'center', fig.height = 7, fig.width = 7}
webplot(REco)
webplot(REco, labels = T)
# webplot(REco, fleets = T, highlight = 'AduRoundfish1')
```



